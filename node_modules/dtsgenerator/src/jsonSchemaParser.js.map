{"version":3,"sources":["src/jsonSchemaParser.js","src/jsonSchemaParser.ts"],"names":[],"mappings":"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","file":"src/jsonSchemaParser.js","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments)).next());\n    });\n};\nconst Debug = require('debug');\nconst request = require('request');\nconst JsonPointer = require('./jsonPointer');\nconst schemaid_1 = require('./schemaid');\nconst typeDefinition_1 = require('./typeDefinition');\nconst writeProcessor_1 = require('./writeProcessor');\nconst debug = Debug('dtsgen');\nconst walkMaker = '<<type>>';\nclass JsonSchemaParser {\n    constructor() {\n        this.typeCache = new Map();\n        this.schemaReference = new Map();\n        this.referenceCache = new Map();\n    }\n    generateDts(prefix, header) {\n        return __awaiter(this, void 0, Promise, function* () {\n            debug(`generate d.ts: prefix=[${prefix}].`);\n            yield this.resolveReference();\n            debug('TypeId list:');\n            for (let typeId of this.typeCache.keys()) {\n                debug('  ' + typeId);\n            }\n            debug('SchemaId list:');\n            for (let ref of this.schemaReference.keys()) {\n                debug('  ' + ref);\n            }\n            debug('Reference list:');\n            for (let schema of this.referenceCache.keys()) {\n                debug('  ' + schema.id);\n                for (let id of this.referenceCache.get(schema).keys()) {\n                    debug('    ' + id);\n                }\n            }\n            const process = new writeProcessor_1.WriteProcessor((baseSchema, ref) => {\n                debug(`Search Reference: schemaId=${baseSchema ? baseSchema.id : null}, ref=${ref}`);\n                const map = this.referenceCache.get(baseSchema);\n                if (map == null) {\n                    return undefined;\n                }\n                const refId = new schemaid_1.SchemaId(ref);\n                const result = map.get(refId.getAbsoluteId());\n                if (result == null) {\n                    if (refId.isJsonPointerHash()) {\n                        const fileId = refId.getFileId();\n                        const schema = fileId ? this.schemaReference.get(fileId).targetSchema : baseSchema;\n                        debug(`  fileId=${fileId}, schemaId=${schema.id}.`);\n                        return JsonPointer.get(schema, refId.getJsonPointerHash());\n                    }\n                }\n                return result;\n            }, prefix);\n            const env = this.createHierarchicalMap(this.typeCache);\n            if (header) {\n                process.outputLine(header);\n            }\n            this.walk(process, env);\n            return process.toDefinition();\n        });\n    }\n    createHierarchicalMap(types) {\n        const map = {};\n        if (types.size === 0) {\n            throw new Error('There is no id in the input schema(s)');\n        }\n        for (let type of types.values()) {\n            const names = type.schemaId.getTypeNames();\n            JsonPointer.set(map, names.concat(walkMaker), type);\n        }\n        return map;\n    }\n    walk(process, env, path = []) {\n        const keys = Object.keys(env).sort();\n        keys.forEach((key) => {\n            const val = env[key];\n            const type = val[walkMaker];\n            if (type instanceof typeDefinition_1.TypeDefinition) {\n                debug(`  walk doProcess: path=${JSON.stringify(path)}, schemaId=${type.schemaId.getAbsoluteId()}`);\n                type.doProcess(process);\n            }\n            delete val[walkMaker];\n            if (Object.keys(val).length > 0) {\n                const nextPath = path.concat(key);\n                if (process.indentLevel === 0) {\n                    process.output('declare ');\n                }\n                process.output('namespace ').outputType(key, true).outputLine(' {');\n                process.increaseIndent();\n                this.walk(process, val, nextPath);\n                process.decreaseIndent();\n                process.outputLine('}');\n            }\n        });\n    }\n    resolveReference() {\n        return __awaiter(this, void 0, Promise, function* () {\n            debug(`resolve reference: reference schema count=${this.referenceCache.size}.`);\n            const error = [];\n            for (let schema of this.referenceCache.keys()) {\n                const map = this.referenceCache.get(schema);\n                for (let [ref, type] of map) {\n                    if (type != null) {\n                        continue;\n                    }\n                    const refId = new schemaid_1.SchemaId(ref);\n                    const fileId = refId.getFileId();\n                    if (fileId && !this.schemaReference.has(fileId)) {\n                        if (!refId.isFetchable()) {\n                            error.push(`$ref target is not found: ${ref}`);\n                            continue;\n                        }\n                        try {\n                            debug(`fetch remote schema: id=[${fileId}].`);\n                            const fetchedSchema = yield this.fetchRemoteSchema(fileId);\n                            this.parseSchema(fetchedSchema, fileId);\n                        }\n                        catch (e) {\n                            error.push(`fail to fetch the $ref target: ${ref}, ${e}`);\n                            continue;\n                        }\n                    }\n                    debug(`resolve reference: ref=[${ref}]`);\n                    if (refId.isJsonPointerHash()) {\n                        const pointer = refId.getJsonPointerHash();\n                        const targetSchema = fileId ? this.schemaReference.get(fileId).rootSchema : schema;\n                        const type = new typeDefinition_1.TypeDefinition(targetSchema, pointer, refId);\n                        map.set(ref, type);\n                        this.addType(type);\n                    }\n                    else {\n                        const target = this.typeCache.get(ref);\n                        if (target == null) {\n                            error.push(`$ref target is not found: ${ref}`);\n                            continue;\n                        }\n                        map.set(ref, target);\n                    }\n                }\n            }\n            if (error.length > 0) {\n                throw new Error(error.join('\\n'));\n            }\n            return true;\n        });\n    }\n    fetchRemoteSchema(fileId) {\n        return new Promise((resolve, reject) => {\n            request.get(fileId, (err, response, body) => {\n                if (err) {\n                    return reject(err);\n                }\n                else if (response.statusCode !== 200) {\n                    return reject(body);\n                }\n                else {\n                    try {\n                        resolve(JSON.parse(body));\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                }\n            });\n        });\n    }\n    parseSchema(schema, url) {\n        if (typeof schema === 'string') {\n            schema = JSON.parse(schema);\n        }\n        debug(`parse schema: schemaId=[${schema.id}], url=[${url}].`);\n        if (schema.id == null) {\n            schema.id = url;\n        }\n        const walk = (s, paths) => {\n            function walkArray(array, pathArray) {\n                array.forEach((item, index) => {\n                    walk(item, pathArray.concat(index.toString()));\n                });\n            }\n            function walkObject(obj, pathObject, isDefinitions = false) {\n                Object.keys(obj).forEach((key) => {\n                    const sub = obj[key];\n                    if (sub != null) {\n                        if (isDefinitions && sub.id == null) {\n                            sub.id = `#/definitions/${key}`;\n                        }\n                        walk(sub, pathObject.concat(key));\n                    }\n                });\n            }\n            if (s == null || typeof s !== 'object') {\n                return;\n            }\n            const allOf = s.allOf;\n            if (allOf != null) {\n                walkArray(allOf, paths.concat('allOf'));\n            }\n            const anyOf = s.anyOf;\n            if (anyOf != null) {\n                walkArray(anyOf, paths.concat('anyOf'));\n            }\n            const oneOf = s.oneOf;\n            if (oneOf != null) {\n                walkArray(oneOf, paths.concat('oneOf'));\n            }\n            const items = s.items;\n            if (items != null) {\n                if (Array.isArray(items)) {\n                    walkArray(items, paths.concat('items'));\n                }\n                else {\n                    walk(items, paths.concat('items'));\n                }\n            }\n            const additionalItems = s.additionalItems;\n            if (additionalItems != null && typeof additionalItems !== 'boolean') {\n                walk(additionalItems, paths.concat('additionalItems'));\n            }\n            const definitions = s.definitions;\n            if (definitions != null) {\n                walkObject(s.definitions, paths.concat('definitions'), true);\n            }\n            const properties = s.properties;\n            if (properties != null) {\n                walkObject(s.properties, paths.concat('properties'));\n            }\n            const patternProperties = s.patternProperties;\n            if (patternProperties != null) {\n                walkObject(s.patternProperties, paths.concat('patternProperties'));\n            }\n            const additionalProperties = s.additionalProperties;\n            if (additionalProperties != null && typeof additionalProperties !== 'boolean') {\n                walk(additionalProperties, paths.concat('additionalProperties'));\n            }\n            if (typeof s.id === 'string') {\n                const type = new typeDefinition_1.TypeDefinition(schema, paths);\n                s.id = type.schemaId.getAbsoluteId();\n                this.addType(type);\n            }\n            if (typeof s.$ref === 'string') {\n                s.$ref = this.addReference(schema, s.$ref);\n            }\n        };\n        walk(schema, []);\n    }\n    addType(g) {\n        const id = g.schemaId;\n        if (id) {\n            this.typeCache.set(id.getAbsoluteId(), g);\n            debug(`add type: id=${id.getAbsoluteId()}`);\n            const fileId = id.getFileId();\n            if (!this.schemaReference.has(fileId)) {\n                this.schemaReference.set(fileId, g);\n            }\n        }\n    }\n    addReference(schema, ref) {\n        let map = this.referenceCache.get(schema);\n        if (map == null) {\n            map = new Map();\n            this.referenceCache.set(schema, map);\n        }\n        const refId = new schemaid_1.SchemaId(ref, [schema.id]);\n        map.set(refId.getAbsoluteId(), null);\n        return refId.getAbsoluteId();\n    }\n    clear() {\n        debug('clear data cache.');\n        this.typeCache.clear();\n        this.schemaReference.clear();\n        this.referenceCache.clear();\n    }\n}\nexports.JsonSchemaParser = JsonSchemaParser;\n","import * as Debug from 'debug';\nimport * as http from 'http';\nimport * as request from 'request';\nimport * as JsonPointer from './jsonPointer';\nimport { SchemaId } from './schemaid';\nimport { TypeDefinition } from './typeDefinition';\nimport { WriteProcessor } from './writeProcessor';\n\nconst debug = Debug('dtsgen');\n\nconst walkMaker = '<<type>>';\n\nexport class JsonSchemaParser {\n    private typeCache = new Map<string, TypeDefinition>();\n    private schemaReference = new Map<string, TypeDefinition>();\n    private referenceCache = new Map<JsonSchemaOrg.Schema, Map<string, TypeDefinition>>();\n\n    public async generateDts(prefix?: string, header?: string): Promise<string> {\n        debug(`generate d.ts: prefix=[${prefix}].`);\n        await this.resolveReference();\n\n        debug('TypeId list:');\n        for (let typeId of this.typeCache.keys()) {\n            debug('  ' + typeId);\n        }\n        debug('SchemaId list:');\n        for (let ref of this.schemaReference.keys()) {\n            debug('  ' + ref);\n        }\n        debug('Reference list:');\n        for (let schema of this.referenceCache.keys()) {\n            debug('  ' + schema.id);\n            for (let id of this.referenceCache.get(schema).keys()) {\n                debug('    ' + id);\n            }\n        }\n\n        const process = new WriteProcessor((baseSchema: JsonSchemaOrg.Schema, ref: string): TypeDefinition => {\n            debug(`Search Reference: schemaId=${baseSchema ? baseSchema.id : null}, ref=${ref}`);\n            const map = this.referenceCache.get(baseSchema);\n            if (map == null) {\n                return undefined;\n            }\n            const refId = new SchemaId(ref);\n            const result = map.get(refId.getAbsoluteId());\n            if (result == null) {\n                if (refId.isJsonPointerHash()) {\n                    const fileId = refId.getFileId();\n                    const schema = fileId ? this.schemaReference.get(fileId).targetSchema : baseSchema;\n                    debug(`  fileId=${fileId}, schemaId=${schema.id}.`);\n                    return JsonPointer.get(schema, refId.getJsonPointerHash());\n                }\n            }\n            return result;\n        }, prefix);\n        const env = this.createHierarchicalMap(this.typeCache);\n        if (header) {\n            process.outputLine(header);\n        }\n        this.walk(process, env);\n        return process.toDefinition();\n    }\n    private createHierarchicalMap(types: Map<string, TypeDefinition>): any {\n        const map: any = {};\n        if (types.size === 0) {\n            throw new Error('There is no id in the input schema(s)');\n        }\n        for (let type of types.values()) {\n            const names = type.schemaId.getTypeNames();\n            JsonPointer.set(map, names.concat(walkMaker), type);\n        }\n        return map;\n    }\n    private walk(process: WriteProcessor, env: any, path: string[] = []): void {\n        const keys = Object.keys(env).sort();\n        keys.forEach((key) => {\n            const val = env[key];\n            const type = val[walkMaker];\n            if (type instanceof TypeDefinition) {\n                debug(`  walk doProcess: path=${JSON.stringify(path)}, schemaId=${type.schemaId.getAbsoluteId()}`);\n                type.doProcess(process);\n            }\n            delete val[walkMaker];\n\n            if (Object.keys(val).length > 0) {\n                const nextPath = path.concat(key);\n                if (process.indentLevel === 0) {\n                    process.output('declare ');\n                }\n                process.output('namespace ').outputType(key, true).outputLine(' {');\n                process.increaseIndent();\n                this.walk(process, val, nextPath);\n                process.decreaseIndent();\n                process.outputLine('}');\n            }\n        });\n    }\n\n    public async resolveReference(): Promise<boolean> {\n        debug(`resolve reference: reference schema count=${this.referenceCache.size}.`);\n        const error: string[] = [];\n        for (let schema of this.referenceCache.keys()) {\n            const map = this.referenceCache.get(schema);\n            for (let [ref, type] of map) {\n                if (type != null) {\n                    continue;\n                }\n                const refId = new SchemaId(ref);\n                const fileId = refId.getFileId();\n                if (fileId && !this.schemaReference.has(fileId)) {\n                    if (!refId.isFetchable()) {\n                        error.push(`$ref target is not found: ${ref}`);\n                        continue;\n                    }\n                    try {\n                        debug(`fetch remote schema: id=[${fileId}].`);\n                        const fetchedSchema = await this.fetchRemoteSchema(fileId);\n                        this.parseSchema(fetchedSchema, fileId);\n                    } catch (e) {\n                        error.push(`fail to fetch the $ref target: ${ref}, ${e}`);\n                        continue;\n                    }\n                }\n                debug(`resolve reference: ref=[${ref}]`);\n                if (refId.isJsonPointerHash()) {\n                    const pointer = refId.getJsonPointerHash();\n                    const targetSchema = fileId ? this.schemaReference.get(fileId).rootSchema : schema;\n                    const type = new TypeDefinition(targetSchema, pointer, refId);\n                    map.set(ref, type);\n                    this.addType(type);\n                } else {\n                    const target = this.typeCache.get(ref);\n                    if (target == null) {\n                        error.push(`$ref target is not found: ${ref}`);\n                        continue;\n                    }\n                    map.set(ref, target);\n                }\n            }\n        }\n        if (error.length > 0) {\n            throw new Error(error.join('\\n'));\n        }\n        return true;\n    }\n    private fetchRemoteSchema(fileId: string): Promise<JsonSchemaOrg.Schema> {\n        return new Promise<JsonSchemaOrg.Schema>((resolve: (schema: JsonSchemaOrg.Schema) => void, reject: (err: any) => void) => {\n            request.get(fileId, (err: any, response: http.IncomingMessage, body: any) => {\n                if (err) {\n                    return reject(err);\n                } else if (response.statusCode !== 200) {\n                    return reject(body);\n                } else {\n                    try {\n                        resolve(JSON.parse(body));\n                    } catch (e) {\n                        reject(e);\n                    }\n                }\n            });\n        });\n    }\n\n    public parseSchema(schema: JsonSchemaOrg.Schema, url?: string): void {\n        if (typeof schema === 'string') {\n            schema = JSON.parse(<string>schema);\n        }\n        debug(`parse schema: schemaId=[${schema.id}], url=[${url}].`);\n\n        if (schema.id == null) {\n            schema.id = url;\n        }\n        const walk = (s: JsonSchemaOrg.Schema, paths: string[]): void => {\n            function walkArray(array: JsonSchemaOrg.Schema[], pathArray: string[]): void {\n                array.forEach((item: JsonSchemaOrg.Schema, index: number) => {\n                    walk(item, pathArray.concat(index.toString()));\n                });\n            }\n            function walkObject(obj: { [name: string]: JsonSchemaOrg.Schema; }, pathObject: string[], isDefinitions: boolean = false): void {\n                Object.keys(obj).forEach((key) => {\n                    const sub = obj[key];\n                    if (sub != null) {\n                        if (isDefinitions && sub.id == null) {\n                            sub.id = `#/definitions/${key}`;\n                        }\n                        walk(sub, pathObject.concat(key));\n                    }\n                });\n            }\n            if (s == null || typeof s !== 'object') {\n                return;\n            }\n\n            const allOf = s.allOf;\n            if (allOf != null) {\n                walkArray(allOf, paths.concat('allOf'));\n            }\n            const anyOf = s.anyOf;\n            if (anyOf != null) {\n                walkArray(anyOf, paths.concat('anyOf'));\n            }\n            const oneOf = s.oneOf;\n            if (oneOf != null) {\n                walkArray(oneOf, paths.concat('oneOf'));\n            }\n\n            const items = s.items;\n            if (items != null) {\n                if (Array.isArray(items)) {\n                    walkArray(items, paths.concat('items'));\n                } else {\n                    walk(items, paths.concat('items'));\n                }\n            }\n            const additionalItems = s.additionalItems;\n            if (additionalItems != null && typeof additionalItems !== 'boolean') {\n                walk(additionalItems, paths.concat('additionalItems'));\n            }\n\n            const definitions = s.definitions;\n            if (definitions != null) {\n                walkObject(s.definitions, paths.concat('definitions'), true);\n            }\n            const properties = s.properties;\n            if (properties != null) {\n                walkObject(s.properties, paths.concat('properties'));\n            }\n            const patternProperties = s.patternProperties;\n            if (patternProperties != null) {\n                walkObject(s.patternProperties, paths.concat('patternProperties'));\n            }\n            const additionalProperties = s.additionalProperties;\n            if (additionalProperties != null && typeof additionalProperties !== 'boolean') {\n                walk(additionalProperties, paths.concat('additionalProperties'));\n            }\n\n            if (typeof s.id === 'string') {\n                const type = new TypeDefinition(schema, paths);\n                s.id = type.schemaId.getAbsoluteId();\n                this.addType(type);\n                // debug(`parse schema: id property found, id=[${s.id}], paths=${JSON.stringify(paths)}.`);\n            }\n            if (typeof s.$ref === 'string') {\n                s.$ref = this.addReference(schema, s.$ref);\n                // debug(`parse schema: $ref property found, $ref=[${s.$ref}], paths=${JSON.stringify(paths)}.`);\n            }\n        };\n        walk(schema, []);\n    }\n    private addType(g: TypeDefinition): void {\n        const id = g.schemaId;\n        if (id) {\n            this.typeCache.set(id.getAbsoluteId(), g);\n            debug(`add type: id=${id.getAbsoluteId()}`);\n            const fileId = id.getFileId();\n            if (!this.schemaReference.has(fileId)) {\n                this.schemaReference.set(fileId, g);\n            }\n        }\n    }\n    private addReference(schema: JsonSchemaOrg.Schema, ref: string): string {\n        let map = this.referenceCache.get(schema);\n        if (map == null) {\n            map = new Map<string, TypeDefinition>();\n            this.referenceCache.set(schema, map);\n        }\n        const refId = new SchemaId(ref, [schema.id]);\n        map.set(refId.getAbsoluteId(), null);\n        return refId.getAbsoluteId();\n    }\n\n    public clear(): void {\n        debug('clear data cache.');\n        this.typeCache.clear();\n        this.schemaReference.clear();\n        this.referenceCache.clear();\n    }\n}\n\n"],"sourceRoot":"/source/"}