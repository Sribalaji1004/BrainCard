{"version":3,"sources":["src/writeProcessor.js","src/writeProcessor.ts"],"names":[],"mappings":"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","file":"src/writeProcessor.js","sourcesContent":["\"use strict\";\nclass WriteProcessor {\n    constructor(refResolver, typePrefix = '') {\n        this.refResolver = refResolver;\n        this.typePrefix = typePrefix;\n        this.indentChar = ' ';\n        this.indentStep = 4;\n        this.indent = 0;\n        this.results = '';\n        this.alreadlyIndentThisLine = false;\n        this.referenceStack = [];\n    }\n    get referenceResolve() {\n        return this.refResolver;\n    }\n    pushReference(referenceName) {\n        return this.referenceStack.push(referenceName);\n    }\n    popReference() {\n        return this.referenceStack.pop();\n    }\n    checkCircularReference(referenceName) {\n        return this.referenceStack.indexOf(referenceName) < 0;\n    }\n    output(str) {\n        this.doIndent();\n        this.results += str;\n        return this;\n    }\n    outputType(type, primitive = false) {\n        if (this.typePrefix && !primitive) {\n            this.output(this.typePrefix);\n        }\n        type = type.replace(/[^0-9A-Za-z_$]/g, '_');\n        if (/^\\d/.test(type)) {\n            type = '$' + type;\n        }\n        this.output(type);\n        return this;\n    }\n    outputKey(name, optional = false) {\n        if (/[^0-9A-Za-z_$]/.test(name) || /^\\d/.test(name)) {\n            this.output('\\\"').output(name).output('\\\"');\n        }\n        else {\n            this.output(name);\n        }\n        if (optional) {\n            this.output('?');\n        }\n        return this;\n    }\n    outputLine(str) {\n        this.doIndent();\n        if (str) {\n            this.output(str);\n        }\n        this.output('\\n');\n        this.alreadlyIndentThisLine = false;\n        return this;\n    }\n    outputJSDoc(spec) {\n        let { description, example } = spec;\n        if (!description && !example) {\n            return this;\n        }\n        this.outputLine('/**');\n        if (description) {\n            description.toString().split('\\n').forEach((line) => {\n                this.output(' * ').outputLine(line);\n            });\n        }\n        if (example) {\n            let split = example.toString().split('\\n');\n            if (split.length === 1) {\n                this.outputLine(` * example: ${example}`);\n            }\n            else {\n                this.outputLine(' * example:');\n                split.forEach((line) => {\n                    this.output(' *   ').outputLine(line);\n                });\n            }\n        }\n        this.outputLine(' */');\n        return this;\n    }\n    doIndent() {\n        if (!this.alreadlyIndentThisLine) {\n            const indent = this.getIndent();\n            this.results += indent;\n            this.alreadlyIndentThisLine = true;\n        }\n        return this;\n    }\n    get indentLevel() {\n        return this.indent;\n    }\n    increaseIndent() {\n        this.indent++;\n        return this;\n    }\n    decreaseIndent() {\n        this.indent--;\n        return this;\n    }\n    getIndent() {\n        return this.repeatString(this.indent * this.indentStep, this.indentChar);\n    }\n    repeatString(n, s) {\n        let result = '';\n        for (let i = 0; i < n; i++) {\n            result += s;\n        }\n        return result;\n    }\n    toDefinition() {\n        return this.results;\n    }\n}\nexports.WriteProcessor = WriteProcessor;\n","import { TypeDefinition } from './typeDefinition';\n\nexport interface ReferenceResolver {\n    (baseSchema: JsonSchemaOrg.Schema, ref: string): TypeDefinition;\n}\n\nexport class WriteProcessor {\n\n    public indentChar = ' ';\n    public indentStep = 4;\n\n    private indent = 0;\n    private results = '';\n    private alreadlyIndentThisLine = false;\n    private referenceStack: string[] = [];\n\n    constructor(private refResolver: ReferenceResolver, private typePrefix: string = '') {}\n\n    get referenceResolve(): ReferenceResolver {\n        return this.refResolver;\n    }\n\n    pushReference(referenceName: string): number {\n        return this.referenceStack.push(referenceName);\n    }\n    popReference(): string {\n        return this.referenceStack.pop();\n    }\n    checkCircularReference(referenceName: string): boolean {\n        return this.referenceStack.indexOf(referenceName) < 0;\n    }\n\n\n    output(str: string): this {\n        this.doIndent();\n        this.results += str;\n        return this;\n    }\n\n    outputType(type: string, primitive: boolean = false): this {\n        if (this.typePrefix && !primitive) {\n            this.output(this.typePrefix);\n        }\n        type = type.replace(/[^0-9A-Za-z_$]/g, '_');\n        if (/^\\d/.test(type)) {\n          type = '$' + type;\n        }\n        this.output(type);\n        return this;\n    }\n\n    outputKey(name: string, optional: boolean = false): this {\n        if (/[^0-9A-Za-z_$]/.test(name) || /^\\d/.test(name)) {\n            this.output('\\\"').output(name).output('\\\"');\n        } else {\n            this.output(name);\n        }\n        if (optional) {\n            this.output('?');\n        }\n        return this;\n    }\n\n    outputLine(str?: string): this {\n        this.doIndent();\n        if (str) {\n            this.output(str);\n        }\n        this.output('\\n');\n        this.alreadlyIndentThisLine = false;\n        return this;\n    }\n\n    outputJSDoc(spec: any): this {\n        let { description, example } = spec;\n        if (!description && !example) {\n            return this;\n        }\n\n        this.outputLine('/**');\n        if (description) {\n            description.toString().split('\\n').forEach((line: string) => {\n                this.output(' * ').outputLine(line);\n            });\n        }\n        if (example) {\n            let split = example.toString().split('\\n');\n            if (split.length === 1) {\n                this.outputLine(` * example: ${example}`);\n            } else {\n                this.outputLine(' * example:');\n                split.forEach((line: string) => {\n                    this.output(' *   ').outputLine(line);\n                });\n            }\n        }\n        this.outputLine(' */');\n        return this;\n    }\n\n    doIndent(): this {\n        if (!this.alreadlyIndentThisLine) {\n            const indent = this.getIndent();\n            this.results += indent;\n            this.alreadlyIndentThisLine = true;\n        }\n        return this;\n    }\n\n    get indentLevel(): number {\n        return this.indent;\n    }\n\n    increaseIndent(): this {\n        this.indent++;\n        return this;\n    }\n\n    decreaseIndent(): this {\n        this.indent--;\n        return this;\n    }\n\n    getIndent(): string {\n        return this.repeatString(this.indent * this.indentStep, this.indentChar);\n    }\n\n    repeatString(n: number, s: string): string {\n        let result = '';\n        for (let i = 0; i < n; i++) {\n            result += s;\n        }\n        return result;\n    }\n\n    toDefinition(): string {\n        return this.results;\n    }\n}\n\n"],"sourceRoot":"/source/"}