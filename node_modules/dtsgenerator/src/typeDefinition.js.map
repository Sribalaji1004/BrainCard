{"version":3,"sources":["src/typeDefinition.js","src/typeDefinition.ts"],"names":[],"mappings":"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","file":"src/typeDefinition.js","sourcesContent":["\"use strict\";\nconst JsonPointer = require('./jsonPointer');\nconst utils = require('./utils');\nconst schemaid_1 = require('./schemaid');\nclass TypeDefinition {\n    constructor(schema, path, refId) {\n        this.schema = schema;\n        this.path = path;\n        this.target = JsonPointer.get(schema, path);\n        if (!this.target || !this.target.id) {\n            this.id = refId || null;\n        }\n        else {\n            const baseId = this.target.id;\n            const parentsId = [];\n            for (let i = path.length - 1; i >= 0; i--) {\n                const parent = JsonPointer.get(schema, path.slice(0, i));\n                if (parent && parent.id && typeof parent.id === 'string') {\n                    parentsId.push(parent.id);\n                }\n            }\n            this.id = new schemaid_1.SchemaId(baseId, parentsId);\n        }\n    }\n    get schemaId() {\n        return this.id;\n    }\n    get rootSchema() {\n        return this.schema;\n    }\n    get targetSchema() {\n        return this.target;\n    }\n    doProcess(process) {\n        this.generateType(process, this.target);\n    }\n    searchRef(process, ref) {\n        const type = process.referenceResolve(this.schema, ref);\n        if (type == null) {\n            throw new Error('Target reference is not found: ' + ref);\n        }\n        return type;\n    }\n    getTypename(id) {\n        let sid = (id instanceof schemaid_1.SchemaId) ? id : new schemaid_1.SchemaId(id);\n        const result = sid.getTypeNames();\n        const myId = this.schemaId;\n        if (myId) {\n            const baseType = myId.getTypeNames().slice(0, -1);\n            for (let name of baseType) {\n                if (result[0] === name) {\n                    result.shift();\n                }\n                else {\n                    break;\n                }\n            }\n            if (result.length === 0) {\n                return [sid.getInterfaceName()];\n            }\n        }\n        return result;\n    }\n    checkSchema(process, base) {\n        if (base.allOf) {\n            const schema = base;\n            base.allOf.forEach((p) => {\n                if (p.$ref) {\n                    p = this.searchRef(process, p.$ref).targetSchema;\n                }\n                utils.mergeSchema(schema, p);\n            });\n            return schema;\n        }\n        return base;\n    }\n    generateType(process, type) {\n        type = this.checkSchema(process, type);\n        const types = type.type;\n        if (types === undefined && (type.properties || type.additionalProperties)) {\n            type.type = 'object';\n        }\n        else if (Array.isArray(types)) {\n            const reduced = utils.reduceTypes(types);\n            type.type = reduced.length === 1 ? reduced[0] : reduced;\n        }\n        process.outputJSDoc(type);\n        if (type.type === 'array') {\n            this.generateTypeCollection(process, type);\n        }\n        else if (type.type === 'object' || type.type === 'any') {\n            this.generateTypeModel(process, type);\n        }\n        else {\n            this.generateDeclareType(process, type);\n        }\n    }\n    generateDeclareType(process, type) {\n        const name = this.id.getInterfaceName();\n        process.output('export type ').outputType(name).output(' = ');\n        this.generateTypeProperty(process, type, true);\n    }\n    generateTypeModel(process, type) {\n        const name = this.id.getInterfaceName();\n        process.output('export interface ').outputType(name).outputLine(' {');\n        process.increaseIndent();\n        if (type.type === 'any') {\n            // TODO this is not permitted property access by dot.\n            process.outputLine('[name: string]: any; // any');\n        }\n        this.generateProperties(process, type);\n        process.decreaseIndent();\n        process.outputLine('}');\n    }\n    generateTypeCollection(process, type) {\n        const name = this.id.getInterfaceName();\n        process.output('export type ').outputType(name).output(' = ');\n        this.generateTypeProperty(process, type.items == null ? {} : type.items, false);\n        process.outputLine('[];');\n    }\n    generateProperties(process, type) {\n        if (type.additionalProperties) {\n            process.output('[name: string]: ');\n            this.generateTypeProperty(process, type.additionalProperties, true);\n        }\n        if (type.properties) {\n            Object.keys(type.properties).forEach((propertyName) => {\n                const property = type.properties[propertyName];\n                process.outputJSDoc(property);\n                this.generatePropertyName(process, propertyName, type);\n                this.generateTypeProperty(process, property);\n            });\n        }\n    }\n    generatePropertyName(process, propertyName, property) {\n        if (propertyName) {\n            const optionalProperty = !property.required || property.required.indexOf(propertyName) < 0;\n            process.outputKey(propertyName, optionalProperty).output(': ');\n        }\n    }\n    generateTypeProperty(process, property, terminate = true) {\n        if (!property)\n            return;\n        property = this.checkSchema(process, property);\n        if (property.$ref) {\n            const ref = this.searchRef(process, property.$ref);\n            if (ref.id == null) {\n                throw new Error('target referenced id is nothing: ' + property.$ref);\n            }\n            this.generateTypePropertyNamedType(process, this.getTypename(ref.id), false, ref.targetSchema, terminate);\n            return;\n        }\n        const anyOf = property.anyOf || property.oneOf;\n        if (anyOf) {\n            this.generateArrayedType(process, anyOf, ' | ', terminate);\n            return;\n        }\n        if (property.enum) {\n            if (!terminate) {\n                process.output('(');\n            }\n            process.output(property.enum.map(s => '\"' + s + '\"').join(' | '));\n            if (!terminate) {\n                process.output(')');\n            }\n            else {\n                process.outputLine(';');\n            }\n            return;\n        }\n        const type = property.type;\n        if (type == null) {\n            this.generateTypePropertyNamedType(process, 'any', true, property, terminate);\n        }\n        else if (typeof type === 'string') {\n            this.generateTypeName(process, type, property, terminate);\n        }\n        else {\n            const types = utils.reduceTypes(type);\n            if (!terminate && types.length > 1) {\n                process.output('(');\n            }\n            types.forEach((t, index) => {\n                const isLast = index === types.length - 1;\n                this.generateTypeName(process, t, property, terminate);\n                if (!isLast) {\n                    process.output(' | ');\n                }\n            });\n            if (!terminate && types.length > 1) {\n                process.output(')');\n            }\n        }\n    }\n    generateArrayedType(process, types, separator, terminate) {\n        if (!terminate) {\n            process.output('(');\n        }\n        types.forEach((type, index) => {\n            const isLast = index === types.length - 1;\n            if (type.id) {\n                this.generateTypePropertyNamedType(process, this.getTypename(type.id), false, type, isLast && terminate);\n            }\n            else {\n                this.generateTypeProperty(process, type, isLast && terminate);\n            }\n            if (!isLast) {\n                process.output(separator);\n            }\n        });\n        if (!terminate) {\n            process.output(')');\n        }\n    }\n    generateTypeName(process, type, property, terminate) {\n        const tsType = utils.toTSType(type, property);\n        if (tsType) {\n            this.generateTypePropertyNamedType(process, tsType, true, property, terminate);\n            return;\n        }\n        if (type === 'object') {\n            process.outputLine('{');\n            process.increaseIndent();\n            this.generateProperties(process, property);\n            process.decreaseIndent();\n            process.output('}');\n            if (terminate) {\n                process.outputLine(';');\n            }\n        }\n        else if (type === 'array') {\n            this.generateTypeProperty(process, property.items == null ? {} : property.items, false);\n            process.output('[]');\n            if (terminate) {\n                process.outputLine(';');\n            }\n        }\n        else {\n            console.error(property);\n            throw new Error('unknown type: ' + property.type);\n        }\n    }\n    generateTypePropertyNamedType(process, typeName, primitiveType, property, terminate = true) {\n        if (Array.isArray(typeName)) {\n            typeName.forEach((type, index) => {\n                const isLast = index === typeName.length - 1;\n                process.outputType(type, isLast ? primitiveType : true);\n                if (!isLast) {\n                    process.output('.');\n                }\n            });\n        }\n        else {\n            process.outputType(typeName, primitiveType);\n        }\n        if (terminate) {\n            process.output(';');\n            this.generateOptionalInformation(process, property, terminate);\n            process.outputLine();\n        }\n        else {\n            this.generateOptionalInformation(process, property, terminate);\n        }\n    }\n    generateOptionalInformation(process, property, terminate = true) {\n        if (!property.format && !property.pattern) {\n            return;\n        }\n        if (terminate) {\n            process.output(' //');\n        }\n        else {\n            process.output(' /*');\n        }\n        if (property.format) {\n            process.output(' ').output(property.format);\n        }\n        if (property.pattern) {\n            process.output(' ').output(property.pattern);\n        }\n        if (!terminate) {\n            process.output(' */ ');\n        }\n    }\n}\nexports.TypeDefinition = TypeDefinition;\n","import * as JsonPointer from './jsonPointer';\nimport * as utils from './utils';\nimport { SchemaId } from './schemaid';\nimport { WriteProcessor } from './writeProcessor';\n\nexport class TypeDefinition {\n    private id: SchemaId;\n    private target: JsonSchemaOrg.Schema;\n\n    constructor(private schema: JsonSchemaOrg.Schema, private path: string[], refId?: SchemaId) {\n        this.target = JsonPointer.get(schema, path);\n        if (!this.target || !this.target.id) {\n            this.id = refId || null;\n        } else {\n            const baseId = this.target.id;\n            const parentsId: string[] = [];\n            for (let i = path.length - 1; i >= 0; i--) {\n                const parent = JsonPointer.get(schema, path.slice(0, i));\n                if (parent && parent.id && typeof parent.id === 'string') {\n                    parentsId.push(parent.id);\n                }\n            }\n            this.id = new SchemaId(baseId, parentsId);\n        }\n    }\n\n    get schemaId(): SchemaId {\n        return this.id;\n    }\n    get rootSchema(): JsonSchemaOrg.Schema {\n        return this.schema;\n    }\n    get targetSchema(): JsonSchemaOrg.Schema {\n        return this.target;\n    }\n\n    public doProcess(process: WriteProcessor): void {\n        this.generateType(process, this.target);\n    }\n\n\n    private searchRef(process: WriteProcessor, ref: string): TypeDefinition {\n        const type = process.referenceResolve(this.schema, ref);\n        if (type == null) {\n            throw new Error('Target reference is not found: ' + ref);\n        }\n        return type;\n    }\n    private getTypename(id: SchemaId | string): string[] {\n        let sid = (id instanceof SchemaId) ? id : new SchemaId(id);\n        const result = sid.getTypeNames();\n        const myId = this.schemaId;\n        if (myId) {\n            const baseType = myId.getTypeNames().slice(0, -1);\n            for (let name of baseType) {\n                if (result[0] === name) {\n                    result.shift();\n                } else {\n                    break;\n                }\n            }\n            if (result.length === 0) {\n                return [sid.getInterfaceName()];\n            }\n        }\n        return result;\n    }\n    private checkSchema(process: WriteProcessor, base: JsonSchemaOrg.Schema): JsonSchemaOrg.Schema {\n        if (base.allOf) {\n            const schema = base;\n            base.allOf.forEach((p) => {\n                if (p.$ref) {\n                    p = this.searchRef(process, p.$ref).targetSchema;\n                }\n                utils.mergeSchema(schema, p);\n            });\n            return schema;\n        }\n        return base;\n    }\n\n    private generateType(process: WriteProcessor, type: JsonSchemaOrg.Schema): void {\n        type = this.checkSchema(process, type);\n        const types = type.type;\n        if (types === undefined && (type.properties || type.additionalProperties)) {\n            type.type = 'object';\n        } else if (Array.isArray(types)) {\n            const reduced = utils.reduceTypes(types);\n            type.type = reduced.length === 1 ? reduced[0] : reduced;\n        }\n\n        process.outputJSDoc(type);\n        if (type.type === 'array') {\n            this.generateTypeCollection(process, type);\n        } else if (type.type === 'object' || type.type === 'any') {\n            this.generateTypeModel(process, type);\n        } else {\n            this.generateDeclareType(process, type);\n        }\n    }\n\n    private generateDeclareType(process: WriteProcessor, type: JsonSchemaOrg.Schema): void {\n        const name = this.id.getInterfaceName();\n        process.output('export type ').outputType(name).output(' = ');\n        this.generateTypeProperty(process, type, true);\n    }\n\n    private generateTypeModel(process: WriteProcessor, type: JsonSchemaOrg.Schema): void {\n        const name = this.id.getInterfaceName();\n        process.output('export interface ').outputType(name).outputLine(' {');\n        process.increaseIndent();\n\n        if (type.type === 'any') {\n            // TODO this is not permitted property access by dot.\n            process.outputLine('[name: string]: any; // any');\n        }\n        this.generateProperties(process, type);\n        process.decreaseIndent();\n        process.outputLine('}');\n    }\n\n    private generateTypeCollection(process: WriteProcessor, type: JsonSchemaOrg.Schema): void {\n        const name = this.id.getInterfaceName();\n        process.output('export type ').outputType(name).output(' = ');\n        this.generateTypeProperty(process, type.items == null ? {} : type.items, false);\n        process.outputLine('[];');\n    }\n\n    private generateProperties(process: WriteProcessor, type: JsonSchemaOrg.Schema): void {\n        if (type.additionalProperties) {\n            process.output('[name: string]: ');\n            this.generateTypeProperty(process, type.additionalProperties, true);\n        }\n        if (type.properties) {\n            Object.keys(type.properties).forEach((propertyName) => {\n                const property = type.properties[propertyName];\n                process.outputJSDoc(property);\n                this.generatePropertyName(process, propertyName, type);\n                this.generateTypeProperty(process, property);\n            });\n        }\n    }\n    private generatePropertyName(process: WriteProcessor, propertyName: string, property: JsonSchemaOrg.Schema): void {\n        if (propertyName) {\n            const optionalProperty = !property.required || property.required.indexOf(propertyName) < 0;\n            process.outputKey(propertyName, optionalProperty).output(': ');\n        }\n    }\n    private generateTypeProperty(process: WriteProcessor, property: JsonSchemaOrg.Schema, terminate = true): void {\n        if (!property)\n            return;\n        property = this.checkSchema(process, property);\n\n        if (property.$ref) {\n            const ref = this.searchRef(process, property.$ref);\n            if (ref.id == null) {\n                throw new Error('target referenced id is nothing: ' + property.$ref);\n            }\n            this.generateTypePropertyNamedType(process, this.getTypename(ref.id), false, ref.targetSchema, terminate);\n            return;\n        }\n        const anyOf = property.anyOf || property.oneOf;\n        if (anyOf) {\n            this.generateArrayedType(process, anyOf, ' | ', terminate);\n            return;\n        }\n        if (property.enum) {\n            if (!terminate) {\n                process.output('(');\n            }\n            process.output(property.enum.map(s => '\"' + s + '\"').join(' | '));\n            if (!terminate) {\n                process.output(')');\n            } else {\n                process.outputLine(';');\n            }\n            return;\n        }\n\n        const type = property.type;\n        if (type == null) {\n            this.generateTypePropertyNamedType(process, 'any', true, property, terminate);\n        } else if (typeof type === 'string') {\n            this.generateTypeName(process, type, property, terminate);\n        } else {\n            const types = utils.reduceTypes(type);\n            if (!terminate && types.length > 1) {\n                process.output('(');\n            }\n            types.forEach((t: string, index: number) => {\n                const isLast = index === types.length - 1;\n                this.generateTypeName(process, t, property, terminate);\n                if (!isLast) {\n                  process.output(' | ');\n                }\n            });\n            if (!terminate && types.length > 1) {\n                process.output(')');\n            }\n        }\n    }\n\n    private generateArrayedType(process: WriteProcessor, types: JsonSchemaOrg.Schema[], separator: string, terminate: boolean): void {\n        if (!terminate) {\n            process.output('(');\n        }\n        types.forEach((type: JsonSchemaOrg.Schema, index: number) => {\n            const isLast = index === types.length - 1;\n            if (type.id) {\n                this.generateTypePropertyNamedType(process, this.getTypename(type.id), false, type, isLast && terminate);\n            } else {\n                this.generateTypeProperty(process, type, isLast && terminate);\n            }\n            if (!isLast) {\n              process.output(separator);\n            }\n        });\n        if (!terminate) {\n            process.output(')');\n        }\n    }\n\n    private generateTypeName(process: WriteProcessor, type: string, property: JsonSchemaOrg.Schema, terminate: boolean): void {\n        const tsType = utils.toTSType(type, property);\n        if (tsType) {\n            this.generateTypePropertyNamedType(process, tsType, true, property, terminate);\n            return;\n        }\n        if (type === 'object') {\n            process.outputLine('{');\n            process.increaseIndent();\n            this.generateProperties(process, property);\n            process.decreaseIndent();\n            process.output('}');\n            if (terminate) {\n                process.outputLine(';');\n            }\n        } else if (type === 'array') {\n            this.generateTypeProperty(process, property.items == null ? {} : property.items, false);\n            process.output('[]');\n            if (terminate) {\n                process.outputLine(';');\n            }\n        } else {\n            console.error(property);\n            throw new Error('unknown type: ' + property.type);\n        }\n    }\n\n    private generateTypePropertyNamedType(process: WriteProcessor, typeName: string | string[], primitiveType: boolean, property: JsonSchemaOrg.Schema, terminate = true): void {\n        if (Array.isArray(typeName)) {\n            typeName.forEach((type: string, index: number) => {\n                const isLast = index === typeName.length - 1;\n                process.outputType(type, isLast ? primitiveType : true);\n                if (!isLast) {\n                    process.output('.');\n                }\n            });\n        } else {\n            process.outputType(typeName, primitiveType);\n        }\n        if (terminate) {\n            process.output(';');\n            this.generateOptionalInformation(process, property, terminate);\n            process.outputLine();\n        } else {\n            this.generateOptionalInformation(process, property, terminate);\n        }\n    }\n    private generateOptionalInformation(process: WriteProcessor, property: JsonSchemaOrg.Schema, terminate = true): void {\n        if (!property.format && !property.pattern) {\n            return;\n        }\n        if (terminate) {\n            process.output(' //');\n        } else {\n            process.output(' /*');\n        }\n        if (property.format) {\n            process.output(' ').output(property.format);\n        }\n        if (property.pattern) {\n            process.output(' ').output(property.pattern);\n        }\n        if (!terminate) {\n            process.output(' */ ');\n        }\n    }\n}\n\n"],"sourceRoot":"/source/"}