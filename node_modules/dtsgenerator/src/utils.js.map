{"version":3,"sources":["src/utils.js","src/utils.ts"],"names":[],"mappings":"AAAA;;;;ACAA,IAAY,QAAK,QAAM,OAAN,CAAjB;AAEA,IAAM,QAAQ,MAAM,QAAN,CAAd;AAEA,SAAA,QAAA,CAAyB,IAAzB,EAAuC,WAAvC,EAAwD;AACpD,YAAQ,IAAR;AACI,aAAK,SAAL;AACI,mBAAO,QAAP;AACJ,aAAK,KAAL;AACA,aAAK,MAAL;AACA,aAAK,WAAL;AACA,aAAK,QAAL;AACA,aAAK,QAAL;AACA,aAAK,SAAL;AACI,mBAAO,IAAP;AACJ,aAAK,QAAL;AACA,aAAK,OAAL;AACI,mBAAO,IAAP;AACJ;AACI,gBAAI,WAAJ,EAAiB;AACb,wBAAQ,KAAR,CAAc,mBAAmB,WAAjC;AACH;AACD,kBAAM,IAAI,KAAJ,CAAU,mBAAmB,IAA7B,CAAN;AAjBR;AAmBH;AApBe,QAAA,QAAA,GAAQ,QAAR;AAsBhB,SAAA,WAAA,CAA4B,KAA5B,EAAiF;AAC7E,QAAI,MAAM,MAAN,GAAe,CAAnB,EAAsB;AAClB,eAAO,KAAP;AACH;AACD,QAAM,MAAM,IAAI,GAAJ,CAAsD,KAAtD,CAAZ;AACA,QAAI,MAAJ,CAAW,MAAX;AACA,QAAI,IAAI,MAAJ,CAAW,SAAX,CAAJ,EAA2B;AACvB,YAAI,GAAJ,CAAQ,QAAR;AACH;AACD,WAAO,MAAM,IAAN,CAAW,IAAI,MAAJ,EAAX,CAAP;AACH;AAVe,QAAA,WAAA,GAAW,WAAX;AAYhB,SAAA,UAAA,CAA2B,GAA3B,EAAsC;AAClC,QAAI,CAAC,GAAL,EAAU,OAAO,GAAP;AACV,UAAM,IAAI,IAAJ,EAAN;AACA,WAAO,IAAI,KAAJ,CAAU,GAAV,EAAe,GAAf,CAAmB;AAAA,eAAK,EAAE,OAAF,CAAU,kCAAV,EAA8C,UAAS,CAAT,EAAY,CAAZ,EAAa;AACtF,mBAAO,EAAE,WAAF,EAAP;AACH,SAF8B,CAAL;AAAA,KAAnB,EAEH,IAFG,CAEE,GAFF,CAAP;AAGH;AANe,QAAA,UAAA,GAAU,UAAV;AAQhB,SAAA,WAAA,CAA4B,CAA5B,EAAoC,CAApC,EAA0C;AACtC,WAAO,IAAP,CAAY,CAAZ,EAAe,OAAf,CAAuB,UAAC,GAAD,EAAY;AAC/B,YAAI,EAAE,GAAF,KAAU,IAAd,EAAoB;AAChB,cAAE,GAAF,IAAS,EAAE,GAAF,CAAT;AACH,SAFD,MAEO;AACH,gBAAM,QAAQ,EAAE,GAAF,CAAd;AACA,gBAAI,QAAO,KAAP,yCAAO,KAAP,eAAwB,EAAE,GAAF,CAAxB,CAAJ,EAAoC;AAChC,yEAAuD,GAAvD;AACA,kBAAE,GAAF,IAAS,KAAT;AACH,aAHD,MAGO,IAAI,MAAM,OAAN,CAAc,KAAd,CAAJ,EAA0B;AAC7B,sBAAM,SAAN,CAAgB,IAAhB,CAAqB,KAArB,CAA2B,EAAE,GAAF,CAA3B,EAAmC,KAAnC;AACH,aAFM,MAEA,IAAI,QAAO,KAAP,yCAAO,KAAP,OAAiB,QAArB,EAA+B;AAClC,uBAAO,MAAP,CAAc,EAAE,GAAF,CAAd,EAAsB,KAAtB;AACH,aAFM,MAEA;AACH,kBAAE,GAAF,IAAS,KAAT;AACH;AACJ;AACJ,KAhBD;AAiBA,WAAO,CAAP;AACH;AAnBe,QAAA,WAAA,GAAW,WAAX","file":"src/utils.js","sourcesContent":["\"use strict\";\nconst Debug = require('debug');\nconst debug = Debug('dtsgen');\nfunction toTSType(type, debugSource) {\n    switch (type) {\n        case 'integer':\n            return 'number';\n        case 'any':\n        case 'null':\n        case 'undefined':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return type;\n        case 'object':\n        case 'array':\n            return null;\n        default:\n            if (debugSource) {\n                console.error('  debugSource=' + debugSource);\n            }\n            throw new Error('unknown type: ' + type);\n    }\n}\nexports.toTSType = toTSType;\nfunction reduceTypes(types) {\n    if (types.length < 2) {\n        return types;\n    }\n    const set = new Set(types);\n    set.delete('null');\n    if (set.delete('integer')) {\n        set.add('number');\n    }\n    return Array.from(set.values());\n}\nexports.reduceTypes = reduceTypes;\nfunction toTypeName(str) {\n    if (!str)\n        return str;\n    str = str.trim();\n    return str.split('$').map(s => s.replace(/(?:^|[^A-Za-z0-9])([A-Za-z0-9])/g, function (_, m) {\n        return m.toUpperCase();\n    })).join('$');\n}\nexports.toTypeName = toTypeName;\nfunction mergeSchema(a, b) {\n    Object.keys(b).forEach((key) => {\n        if (a[key] == null) {\n            a[key] = b[key];\n        }\n        else {\n            const value = b[key];\n            if (typeof value !== typeof a[key]) {\n                debug(`mergeSchema warning: type is missmatched, key=${key}`);\n                a[key] = value;\n            }\n            else if (Array.isArray(value)) {\n                Array.prototype.push.apply(a[key], value);\n            }\n            else if (typeof value === 'object') {\n                Object.assign(a[key], value);\n            }\n            else {\n                a[key] = value;\n            }\n        }\n    });\n    return a;\n}\nexports.mergeSchema = mergeSchema;\n","import * as Debug from 'debug';\n\nconst debug = Debug('dtsgen');\n\nexport function toTSType(type: string, debugSource?: any): string {\n    switch (type) {\n        case 'integer':\n            return 'number';\n        case 'any':\n        case 'null':\n        case 'undefined':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return type;\n        case 'object':\n        case 'array':\n            return null;\n        default:\n            if (debugSource) {\n                console.error('  debugSource=' + debugSource);\n            }\n            throw new Error('unknown type: ' + type);\n    }\n}\n\nexport function reduceTypes(types: JsonSchemaOrg.Schema.Definitions.SimpleTypes[]): JsonSchemaOrg.Schema.Definitions.SimpleTypes[] {\n    if (types.length < 2) {\n        return types;\n    }\n    const set = new Set<JsonSchemaOrg.Schema.Definitions.SimpleTypes>(types);\n    set.delete('null');\n    if (set.delete('integer')) {\n        set.add('number');\n    }\n    return Array.from(set.values());\n}\n\nexport function toTypeName(str: string): string {\n    if (!str) return str;\n    str = str.trim();\n    return str.split('$').map(s => s.replace(/(?:^|[^A-Za-z0-9])([A-Za-z0-9])/g, function(_, m) {\n        return m.toUpperCase();\n    })).join('$');\n}\n\nexport function mergeSchema(a: any, b: any): any {\n    Object.keys(b).forEach((key: string) => {\n        if (a[key] == null) {\n            a[key] = b[key];\n        } else {\n            const value = b[key];\n            if (typeof value !== typeof a[key]) {\n                debug(`mergeSchema warning: type is missmatched, key=${key}`);\n                a[key] = value;\n            } else if (Array.isArray(value)) {\n                Array.prototype.push.apply(a[key], value);\n            } else if (typeof value === 'object') {\n                Object.assign(a[key], value);\n            } else {\n                a[key] = value;\n            }\n        }\n    });\n    return a;\n}\n\n"],"sourceRoot":"/source/"}