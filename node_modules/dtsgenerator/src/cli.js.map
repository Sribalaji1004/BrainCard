{"version":3,"sources":["src/cli.js","src/cli.ts"],"names":[],"mappings":"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","file":"src/cli.js","sourcesContent":["\"use strict\";\nconst fs = require('fs');\nconst path = require('path');\nconst program = require('commander');\nconst mkdirp = require('mkdirp');\nconst glob = require('glob');\nconst index_1 = require('./index');\nconst pkg = require('../package.json');\n// <hoge> is reuired, [hoge] is optional\nprogram\n    .version(pkg.version)\n    .usage('[options] <file ... | file patterns using node-glob>')\n    .option('-o, --out [file]', 'output d.ts filename.')\n    .option('-p, --prefix [type prefix]', 'set the prefix of interface name. default is nothing.')\n    .parse(process.argv);\nconst opts = program;\nif (opts.args.length === 0) {\n    readSchemasFromStdin(processGenerate);\n}\nelse {\n    readSchemasFromFiles(processGenerate);\n}\nfunction readSchemasFromStdin(callback) {\n    let data = '';\n    process.stdin.setEncoding('utf-8');\n    process.stdin.on('readable', () => {\n        let chunk;\n        while (chunk = process.stdin.read()) {\n            if (typeof chunk === 'string') {\n                data += chunk;\n            }\n        }\n    });\n    process.stdin.on('end', () => {\n        let schemas = JSON.parse(data);\n        if (!Array.isArray(schemas)) {\n            schemas = [schemas];\n        }\n        callback(null, schemas);\n    });\n}\nfunction readSchemasFromFiles(callback) {\n    let promises = [];\n    opts.args.forEach((arg) => {\n        const files = glob.sync(arg);\n        promises = promises.concat(files.map((file) => {\n            return new Promise((resolve, reject) => {\n                fs.readFile(file, { encoding: 'utf-8' }, (err, content) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(JSON.parse(content));\n                    }\n                });\n            });\n        }));\n    });\n    Promise.all(promises).then((schemas) => {\n        callback(null, schemas);\n    }).catch((err) => {\n        callback(err, []);\n    });\n}\nfunction processGenerate(err, schemas) {\n    if (err) {\n        throw err;\n    }\n    index_1.default(schemas, opts.prefix).then((result) => {\n        if (opts.out) {\n            mkdirp.sync(path.dirname(opts.out));\n            fs.writeFileSync(opts.out, result, { encoding: 'utf-8' });\n        }\n        else {\n            console.log(result);\n        }\n    }).catch((e) => {\n        console.error(e.stack || e);\n    });\n}\n","import fs = require('fs');\nimport path = require('path');\nimport program = require('commander');\nimport mkdirp = require('mkdirp');\nimport glob = require('glob');\n\nimport dtsgenerator from './index';\n\nconst pkg = require('../package.json');\n\n\n// <hoge> is reuired, [hoge] is optional\nprogram\n    .version(pkg.version)\n    .usage('[options] <file ... | file patterns using node-glob>')\n    .option('-o, --out [file]', 'output d.ts filename.')\n    .option('-p, --prefix [type prefix]', 'set the prefix of interface name. default is nothing.')\n    .parse(process.argv);\n\ninterface CommandOptions {\n    args: string[];\n    out?: string;\n    prefix?: string;\n}\nconst opts = program as CommandOptions;\n\nif (opts.args.length === 0) {\n    readSchemasFromStdin(processGenerate);\n} else {\n    readSchemasFromFiles(processGenerate);\n}\n\nfunction readSchemasFromStdin(callback: (err: any, schemas: JsonSchemaOrg.Schema[]) => void): void {\n    let data = '';\n    process.stdin.setEncoding('utf-8');\n\n    process.stdin.on('readable', () => {\n        let chunk: string | Buffer;\n        while (chunk = process.stdin.read()) {\n            if (typeof chunk === 'string') {\n                data += chunk;\n            }\n        }\n    });\n    process.stdin.on('end', () => {\n        let schemas = JSON.parse(data);\n        if (!Array.isArray(schemas)) {\n            schemas = [schemas];\n        }\n        callback(null, schemas);\n    });\n}\n\nfunction readSchemasFromFiles(callback: (err: any, schemas: JsonSchemaOrg.Schema[]) => void): void {\n    let promises: Promise<JsonSchemaOrg.Schema>[] = [];\n    opts.args.forEach((arg) => {\n        const files = glob.sync(arg);\n        promises = promises.concat(files.map((file: string) => {\n            return new Promise((resolve: (res: JsonSchemaOrg.Schema) => void, reject: (err: any) => void) => {\n                fs.readFile(file, { encoding: 'utf-8' }, (err: any, content: string) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(JSON.parse(content));\n                    }\n                });\n            });\n        }));\n    });\n    Promise.all(promises).then((schemas: JsonSchemaOrg.Schema[]) => {\n        callback(null, schemas);\n    }).catch((err: any) => {\n        callback(err, []);\n    });\n}\n\nfunction processGenerate(err: any, schemas: JsonSchemaOrg.Schema[]): void {\n    if (err) {\n        throw err;\n    }\n    dtsgenerator(schemas, opts.prefix).then((result) => {\n        if (opts.out) {\n            mkdirp.sync(path.dirname(opts.out));\n            fs.writeFileSync(opts.out, result, { encoding: 'utf-8' });\n        } else {\n            console.log(result);\n        }\n    }).catch((e: any) => {\n        console.error(e.stack || e);\n    });\n}\n\n"],"sourceRoot":"/source/"}